# 背包问题

## 01背包

最基本的背包问题就是01背包问题（01 knapsack problem）：一共有**N**件物品，第i（i从1开始）件物品的重量为**w[i]**，价值为**v[i]**。在总重量不超过背包承载**上限W**的情况下，能够装入背包的最大价值是多少？

```text
dp[i][j]表示将前i件物品装进限重为j的背包可以获得的最大价值, 0<=i<=N, 0<=j<=W
```

那么我们可以将`dp[0][0...W]`初始化为0，表示将前0个物品（即没有物品）装入书包的最大价值为0。那么当 i > 0 时`dp[i][j]`有两种情况：

1. 不装入第i件物品，即`dp[i−1][j]`；

1. 装入第i件物品（前提是j>=w[i]，能装下），即`dp[i−1][j−w[i]] + v[i]`。

需要注意的是，为了防止上一层循环的`dp[0,...,j-1]`被覆盖，循环的时候 j 只能**逆向枚举**（空间优化前没有这个限制），伪代码为：

```text
// 01背包问题伪代码(空间优化版)
dp[0,...,W] = 0
for i = 1,...,N
    for j = W,...,w[i] // 必须逆向枚举!!! 因为j==W只可能会在第一次用到
        dp[j] = max(dp[j], dp[j−w[i]]+v[i])
```

时间复杂度为O(NW), 空间复杂度为O(W)。由于W的值是W的位数的幂，所以这个时间复杂度是伪多项式时间。

动态规划的核心思想**避免重复计算**在01背包问题中体现得淋漓尽致。第i件物品装入或者不装入而获得的最大价值完全可以由前面i-1件物品的最大价值决定，暴力枚举忽略了这个事实。

## 完全背包

### 分析1

完全背包（unbounded knapsack problem）与01背包不同就是每种物品可以有无限多个：一共有**N种物品**，**每种物品有无限多个**，第i（i从1开始）种物品的重量为w[i]，价值为v[i]。在总重量不超过背包承载上限W的情况下，能够装入背包的最大价值是多少？

我们的目标和变量和01背包没有区别，所以我们可定义与01背包问题几乎完全相同的状态dp:

```text
dp[i][j]表示将前i种物品装进限重为j的背包可以获得的最大价值, 0<=i<=N, 0<=j<=W
```

初始状态也是一样的，我们将`dp[0][0...W]`初始化为0，表示将前0种物品（即没有物品）装入书包的最大价值为0。那么当 i > 0 时`dp[i][j]`也有两种情况：

1. 不装入第i种物品，即`dp[i−1][j]`，同01背包；
2. 装入第i种物品，此时和01背包不太一样，因为每种物品有无限个（但注意书包限重是有限的），所以此时不应该转移到`dp[i−1][j−w[i]]`而应该转移到`dp[i][j−w[i]]`，即装入第i种商品后还可以再继续装入第种商品。

所以状态转移方程为

```text
dp[i][j] = max(dp[i−1][j], dp[i][j−w[i]]+v[i]) // j >= w[i]
```

和01背包问题类似，也可进行空间优化，优化后不同点在于这里的 j 只能**正向枚举**而01背包只能逆向枚举，因为这里的max第二项是`dp[i]`而01背包是`dp[i-1]`，即这里就是需要覆盖而01背包需要避免覆盖。所以伪代码如下：

```text
// 完全背包问题思路一伪代码(空间优化版)
dp[0,...,W] = 0
for i = 1,...,N
    for j = w[i],...,W // 必须正向枚举!!!
        dp[j] = max(dp[j], dp[j−w[i]]+v[i])
```

### 分析2

除了分析一的思路外，完全背包还有一种常见的思路，但是复杂度高一些。我们从装入第 i 种物品多少件出发，01背包只有两种情况即取0件和取1件，而这里是取0件、1件、2件...直到超过限重（k > j/w[i]），所以状态转移方程为：

```text
# k为装入第i种物品的件数, k <= j/w[i]
dp[i][j] = max{(dp[i-1][j − k*w[i]] + k*v[i]) for every k}
```

同理也可以进行空间优化，需要注意的是，这里max里面是`dp[i-1]`，和01背包一样，所以 j 必须**逆向枚举**，优化后伪代码为

```text
// 完全背包问题思路二伪代码(空间优化版)
dp[0,...,W] = 0
for i = 1,...,N
    for j = W,...,w[i] // 必须逆向枚举!!!
        for k = [0, 1,..., j/w[i]]
            dp[j] = max(dp[j], dp[j−k*w[i]]+k*v[i])
```

相比于分析一，此种方法不是在O(1)时间求得dp[i][j]，所以总的时间复杂度就比分析一大些了，为 ![[公式]](https://www.zhihu.com/equation?tex=+O(NW+\frac+W+{\bar{w}}))级别。

### 分析3

01背包问题是最基本的背包问题，我们可以考虑把完全背包问题转化为01背包问题来解：将一种物品转换成若干件只能装入0件或者1件的01背包中的物品。

最简单的想法是，考虑到第 i 种物品最多装入 W/w[i] 件，于是可以把第 i 种物品转化为 W/w[i] 件费用及价值均不变的物品，然后求解这个01背包问题。

更高效的转化方法是采用二进制的思想：把第 i 种物品拆成重量为 ![[公式]](https://www.zhihu.com/equation?tex=w_i+2^k) 、价值为 ![[公式]](https://www.zhihu.com/equation?tex=v_i+2^k) 的若干件物品，其中 k 取遍满足 ![[公式]](https://www.zhihu.com/equation?tex=w_i+2^k+\le+W) 的非负整数。这是因为不管最优策略选几件第 i 种物品，总可以表示成若干个刚才这些物品的和（例：13 = 1 + 4 + 8)。这样就将转换后的物品数目降成了对数级别。

## 多重背包

多重背包（bounded knapsack problem）与前面不同就是每种物品是有限个：一共有N种物品，第i（i从1开始）种物品的数量为n[i]，重量为w[i]，价值为v[i]。在总重量不超过背包承载上限W的情况下，能够装入背包的最大价值是多少？

### 分析1

此时的分析和完全背包的分析二差不多，也是从装入第 i 种物品多少件出发：装入第i种物品0件、1件、...n[i]件（还要满足不超过限重）。所以状态方程为：

```text
# k为装入第i种物品的件数, k <= min(n[i], j/w[i])
dp[i][j] = max{(dp[i-1][j − k*w[i]] + k*v[i]) for every k}
```

同理也可以进行空间优化，而且 j 也必须**逆向枚举**，优化后伪代码为

```text
// 完全背包问题思路二伪代码(空间优化版)
dp[0,...,W] = 0
for i = 1,...,N
    for j = W,...,w[i] // 必须逆向枚举!!!
        for k = [0, 1,..., min(n[i], j/w[i])]
            dp[j] = max(dp[j], dp[j−k*w[i]]+k*v[i])
```

总的时间复杂度约为 ![[公式]](https://www.zhihu.com/equation?tex=O(NW{\bar{n}})+%3D+O(W+\sum_i+{n_i})) 级别。

### 分析2

类似的思路可以将多重背包转换成01背包问题，采用二进制思路将第 i 种物品分成了 ![[公式]](https://www.zhihu.com/equation?tex=O(logn_i)) 件物品，将原问题转化为了复杂度为 ![[公式]](https://www.zhihu.com/equation?tex=O(W+\sum_i{logn_i})) 的 01 背包问题，相对于分析一是很大的改进。

## 其他情形

### 恰好装满

背包问题有时候还有一个限制就是必须恰好装满背包，此时基本思路没有区别，只是在初始化的时候有所不同。

如果没有恰好装满背包的限制，我们将dp全部初始化成0就可以了。因为任何容量的背包都有一个合法解“什么都不装”，这个解的价值为0，所以初始时状态的值也就全部为0了。如果有恰好装满的限制，那只应该将`dp[0,...,N][0]`初始为0，其它dp值均初始化为`-inf`，因为此时只有容量为0的背包可以在什么也不装情况下被“恰好装满”，其它容量的背包初始均没有合法的解，应该被初始化为`-inf`，在最后进行判断的时候直接判断dp[sum/2]是否大于0即可，因为如果不存在则这个值为-inf。

### 求方法总数

除了在给定每个物品的价值后求可得到的最大价值外，还有一类问题是问装满背包或将背包装至某一指定容量的方案总数。对于这类问题，需要将状态转移方程中的 max 改成 sum ，大体思路是不变的。例如若每件物品均是完全背包中的物品，转移方程即为

```text
dp[i][j] = sum(dp[i−1][j], dp[i][j−w[i]]) // j >= w[i]
```

### 二维背包

前面讨论的背包容量都是一个量：重量。二维背包问题是指每个背包有两个限制条件（比如重量和体积限制），选择物品必须要满足这两个条件。此类问题的解法和一维背包问题不同就是dp数组要多开一维，其他和一维背包完全一样

一般而言，背包问题是要求一个最优值，如果要求输出这个最优值的方案，可以参照一般动态规划问题输出方案的方法：记录下每个状态的最优值是由哪一个策略推出来的，这样便可根据这条策略找到上一个状态，从上一个状态接着向前推即可。

以01背包为例，我们可以再用一个数组G[i][j]来记录方案，设 `G[i][j] = 0`表示计算 dp[i][j] 的值时是采用了max中的前一项(也即dp[i−1][j])，`G[i][j] = 1` 表示采用了方程的后一项。即分别表示了两种策略: 未装入第 i 个物品及装了第 i 个物品。其实我们也可以直接从求好的dp[i][j]反推方案：若 `dp[i][j] = dp[i−1][j]` 说明未选第i个物品，反之说明选了。

https://zhuanlan.zhihu.com/p/93857890